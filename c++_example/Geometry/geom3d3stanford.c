// Geometry shader demo by Ingemar Ragnemalm// Includes four simple shaders; pass-through, flat shader, "crack" shader and wireframe.// 2014: Cleaned up a bit and added mouse dragging support.#ifdef __APPLE__	#include <OpenGL/gl3.h>	#include "MicroGlut.h"	// uses framework Cocoa#endif#include "GL_utilities.h"#include "VectorUtils3.h"#include "loadobj.h"#include "LoadTGA.h"// vertex array objectunsigned int bunnyVertexArrayObjID;Model *m;// Reference to shader program#define kNumPrograms 4GLuint program[kNumPrograms];int currentProgram;GLuint tex;mat4 worldToViewMatrix, modelToWorldMatrix;void init(void){	int i;	mat4 camMatrix;	mat4 projectionMatrix;		// GL inits	glClearColor(1,1,1,0);	glEnable(GL_DEPTH_TEST);	glEnable(GL_CULL_FACE);	glCullFace(GL_TRUE);	// Load and compile shaders	program[0] = loadShaders("minimal.vert", "minimal.frag");	program[1] = loadShadersG("minimal.vert", "minimal.frag", "flatshading.gs");	program[2] = loadShadersG("minimal.vert", "minimal.frag", "cracking.gs");	program[3] = loadShadersG("minimal.vert", "black.frag", "wireframe.gs");	currentProgram = 1;	glUseProgram(program[currentProgram]);		// Upload geometry to the GPU:	m = LoadModelPlus("stanford-bunny900.obj");	CenterModel(m);	ScaleModel(m, 5, 5, 5);	ReloadModelData(m);	modelToWorldMatrix = IdentityMatrix();	worldToViewMatrix = lookAt(0,0.4,1.4, 0,0,0, 0,1,0);	projectionMatrix = frustum(-0.4, 0.4, -0.4, 0.4, 1.0, 300.0);		for (i = 0; i < kNumPrograms; i++)	{		glUseProgram(program[i]);				glUniformMatrix4fv(glGetUniformLocation(program[i], "projMatrix"), 1, GL_TRUE, projectionMatrix.m);//		glUniformMatrix4fv(glGetUniformLocation(program[currentProgram], "worldToViewMatrix"), 1, GL_TRUE, worldToViewMatrix.m);			glUniform1i(glGetUniformLocation(program[i], "tex"), 0); // Texture unit 0		LoadTGATextureSimple("maskros512.tga", &tex); // 5c	}}GLfloat a = 0.0;void display(void){	// clear the screen	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);		glUseProgram(program[currentProgram]);	mat4 modelViewMatrix = Mult(worldToViewMatrix, modelToWorldMatrix);	glUniformMatrix4fv(glGetUniformLocation(program[currentProgram], "modelViewMatrix"), 1, GL_TRUE, modelViewMatrix.m);	DrawModel(m, program[currentProgram], "inPosition", "inNormal", "inTexCoord");		glutPostRedisplay();}void key(unsigned char key, int x, int y){	if (key >= '1' && key <= '1'+kNumPrograms)	{		currentProgram = key - '1';	}}int prevx = 0, prevy = 0;void mouseUpDown(int button, int state, int x, int y){	if (state == GLUT_DOWN)	{		prevx = x;		prevy = y;	}}void mouseDragged(int x, int y){	vec3 p;	mat4 m;		// This is a simple and IMHO really nice trackball system:	// You must have two things, the worldToViewMatrix and the modelToWorldMatrix	// (and the latter is modified).		// Use the movement direction to create an orthogonal rotation axis	p.y = x - prevx;	p.x = -(prevy - y);	p.z = 0;	// Transform the view coordinate rotation axis to world coordinates!	mat3 wv3 = mat4tomat3(worldToViewMatrix);	p = MultMat3Vec3(InvertMat3(wv3), p);	// Create a rotation around this axis and premultiply it on the model-to-world matrix	m = ArbRotate(p, sqrt(p.x*p.x + p.y*p.y) / 50.0);	modelToWorldMatrix = Mult(m, modelToWorldMatrix);		prevx = x;	prevy = y;		glutPostRedisplay();}int main(int argc, const char *argv[]){	glutInit(&argc, argv);	glutInitContextVersion(3, 2);	glutInitWindowSize (800, 800);	glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH);	glutCreateWindow ("GL3 geometry shading example");	glutDisplayFunc(display);	init ();	glutKeyboardFunc(key);	glutMouseFunc(mouseUpDown);	glutMotionFunc(mouseDragged);	glutRepeatingTimerFunc(20);	glutMainLoop();	exit(0);}
